<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: script.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: script.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Zmienna globalna reprezentujƒÖca stan min na planszy.
 * @global
 * @type {boolean[]} 
 */
let mines;

/**
 * Zmienna ≈õledzƒÖca stan rozpoczƒôcia gry.
 * @type {boolean}
 */
let gameStarted = false;

/**
 * Zmienna globalna przechowujƒÖca liczbƒô ods≈Çoniƒôtych kom√≥rek na planszy.
 * @global
 * @type {number} 
 */
let revealedCells;

/**
 * Zmienna globalna przechowujƒÖca liczbƒô pozosta≈Çych do ods≈Çoniƒôcia kom√≥rek na planszy.
 * @global
 * @type {number} 
 */
let remainingCells;

/**
 * Zmienna globalna przechowujƒÖca czas rozpoczƒôcia gry.
 * @global
 * @type {number} 
 */
let startTime;

/**
 * Zmienna globalna przechowujƒÖca identyfikator interwa≈Çu dla licznika czasu gry.
 * @global
 * @type {number} 
 */
let timerInterval;

/**
 * Element HTML reprezentujƒÖcy planszƒô gry.
 * @global
 * @type {HTMLElement} 
 */
const board = document.getElementById("board");

/**
 * Element HTML reprezentujƒÖcy pole wyboru poziomu trudno≈õci.
 * @global
 * @type {HTMLSelectElement} 
 */
const difficultySelect = document.getElementById("difficultySelect");

/**
 * Element HTML reprezentujƒÖcy pole wprowadzania nazwy gracza.
 * @global
 * @type {HTMLInputElement} 
 */
const playerNameInput = document.getElementById("playerNameInput");

/**
 * Element HTML reprezentujƒÖcy wy≈õwietlacz czasu gry.
 * @global
 * @type {HTMLElement} 
 */
const timerDisplay = document.getElementById("timer");

/**
 * Element HTML reprezentujƒÖcy wy≈õwietlacz wynik√≥w graczy.
 * @global
 * @type {HTMLElement} 
 */
const playerScoresDisplay = document.getElementById("playerScores");

/**
 * Funkcja tworzƒÖca kom√≥rkƒô planszy.
 * Tworzy nowy element div reprezentujƒÖcy kom√≥rkƒô planszy.
 * Dodaje klasƒô CSS "cell" do kom√≥rki.
 * Ustawia atrybut dataset z indeksem kom√≥rki.
 * Dodaje zdarzenie klikniƒôcia kom√≥rki.
 * Dodaje utworzonƒÖ kom√≥rkƒô do elementu planszy (board).
 * @param {number} index - Indeks kom√≥rki
 * @function
 */
function createCell(index) {
    const cell = document.createElement("div");
    cell.classList.add("cell");
    cell.dataset.index = index;
    cell.addEventListener("click", handleCellClick);
    board.appendChild(cell);
}

/**
 * Obs≈Çuga klikniƒôcia na kom√≥rkƒô planszy.
 * Pobiera klikniƒôtƒÖ kom√≥rkƒô planszy i indeks kom√≥rki z atrybutu dataset.
 * Sprawdza, czy kom√≥rka zawiera minƒô.
 * Je≈õli tak to:
 * Wywo≈Çuje funkcjƒô ujawniajƒÖcƒÖ wszystkie miny.
 * Wy≈õwietla komunikat o przegranej grze.
 * Zatrzymuje licznik czasu.
 * Zapisuje wynik gracza jako przegranƒÖ.
 * W przeciwnym razie:
 * Ujawnia klikniƒôtƒÖ kom√≥rkƒô.
 * Sprawdza warunek wygranej.
 * @param {Event} event - Zdarzenie klikniƒôcia
 * @function
 */
function handleCellClick(event) {
    const clickedCell = event.target;
    const index = parseInt(clickedCell.dataset.index);

    if (mines[index]) {
        revealMines();
        alert("Game over!");
        stopTimer();
        savePlayerScore(false);
    } else {
        revealCell(index);
        checkWinCondition();
    }
}

/**
 * Sprawdza warunek wygranej gry.
 * Sprawdza, czy wszystkie kom√≥rki zosta≈Çy odkryte.
 * Je≈õli tak to:
 * Wy≈õwietla komunikat o wygranej grze.
 * Zatrzymuje licznik czasu.
 * Zapisuje wynik gracza jako wygranƒÖ.
 * @function
 */
function checkWinCondition() {
    if (remainingCells === 0) {
        alert("Congratulations! You won!");
        stopTimer();
        savePlayerScore(true);
    }
}

/**
 * Ods≈Çania kom√≥rkƒô na planszy.
 * Pobiera klikniƒôtƒÖ kom√≥rkƒô planszy na podstawie jej indeksu.
 * Oblicza liczbƒô min sƒÖsiadujƒÖcych z kom√≥rkƒÖ przez wywo≈Çanie funkcji countAdjacentMines.
 * Sprawdza, czy kom√≥rka nie zosta≈Ça jeszcze ods≈Çoniƒôta.
 * Je≈õli tak to:
 * Ustawia tekst kom√≥rki na liczbƒô sƒÖsiadujƒÖcych min.
 * Dodaje klasƒô "revealed" do ods≈Çoniƒôtej kom√≥rki.
 * Zwiƒôksza licznik ods≈Çoniƒôtych kom√≥rek.
 * Zmniejsza licznik pozosta≈Çych do ods≈Çoniƒôcia kom√≥rek.
 * Je≈õli kom√≥rka nie ma sƒÖsiadujƒÖcych min, ods≈Çania sƒÖsiadujƒÖce kom√≥rki.
 * @param {number} index - Indeks kom√≥rki
 * @function
 */
function revealCell(index) {
    const clickedCell = document.querySelector(`.cell[data-index="${index}"]`);
    const mineCount = countAdjacentMines(index);

    if (!clickedCell.classList.contains("revealed")) {
        clickedCell.textContent = mineCount;
        clickedCell.classList.add("revealed");
        revealedCells++;
        remainingCells--;

        if (mineCount === 0) {
            const neighbors = getNeighbors(index);
            neighbors.forEach(neighbor => revealCell(neighbor));
        }
    }
}

/**
 * Liczy liczbƒô sƒÖsiadujƒÖcych min.
 * Pobiera sƒÖsiadujƒÖce indeksy kom√≥rek.
 * Filtruje sƒÖsiadujƒÖce kom√≥rki, aby uzyskaƒá tylko te, kt√≥re zawierajƒÖ miny,a nastƒôpnie zwraca ich liczbƒô.
 * @param {number} index - Indeks kom√≥rki
 * @returns {number} Liczba sƒÖsiednich min
 * @function
 */
function countAdjacentMines(index) {
    const neighbors = getNeighbors(index);
    return neighbors.filter(neighbor => mines[neighbor]).length;
}

/**
 * Zwraca indeksy sƒÖsiadujƒÖcych kom√≥rek.
 * Oblicza numer wiersza na podstawie indeksu kom√≥rki.
 * Oblicza numer kolumny na podstawie indeksu kom√≥rki.
 * Tworzy pustƒÖ tablicƒô na indeksy sƒÖsiadujƒÖcych kom√≥rek.
 * Iteruje przez sƒÖsiadujƒÖce wiersze.
 * Iteruje przez sƒÖsiadujƒÖce kolumny.
 * Sprawdza, czy sƒÖsiadujƒÖca kom√≥rka mie≈õci siƒô w obszarze planszy i czy nie jest to ta sama kom√≥rka (indeks r√≥wny indeksowi kom√≥rki).
 * Oblicza indeks sƒÖsiadujƒÖcej kom√≥rki i dodaje go do tablicy neighbors.
 * Zwraca tablicƒô indeks√≥w sƒÖsiadujƒÖcych kom√≥rek.
 * @param {number} index - Indeks kom√≥rki
 * @returns {number[]} Indeksy sƒÖsiadujƒÖcych kom√≥rek
 * @function
 */
function getNeighbors(index) {
    const row = Math.floor(index / Math.sqrt(mines.length));
    const col = index % Math.sqrt(mines.length);
    const neighbors = [];

    for (let i = row - 1; i &lt;= row + 1; i++) {
        for (let j = col - 1; j &lt;= col + 1; j++) {
            if (i >= 0 &amp;&amp; i &lt; Math.sqrt(mines.length) &amp;&amp; j >= 0 &amp;&amp; j &lt; Math.sqrt(mines.length) &amp;&amp; !(i === row &amp;&amp; j === col)) {
                neighbors.push(i * Math.sqrt(mines.length) + j);
            }
        }
    }

    return neighbors;
}

/**
 * Ods≈Çania wszystkie miny na planszy.
 * Pobiera wszystkie kom√≥rki planszy.
 * Iteruje przez ka≈ºdƒÖ kom√≥rkƒô.
 * Pobiera indeks kom√≥rki.
 * Sprawdza, czy kom√≥rka zawiera minƒô.
 * Je≈õli tak to:
 * Ustawia tekst kom√≥rki na symbol bomby.
 * Dodaje klasƒô "mine" do kom√≥rki, aby wskazaƒá, ≈ºe zawiera minƒô.
 * @function
 */
function revealMines() {
    const cells = document.querySelectorAll(".cell");
    cells.forEach(cell => {
        const index = parseInt(cell.dataset.index);
        if (mines[index]) {
            cell.textContent = "üí£";
            cell.classList.add("mine");
        }
    });
}

/**
 * Inicjalizuje planszƒô gry.
 * Ustawia styl kolumn planszy za pomocƒÖ CSS Grid.
 * Tworzy kom√≥rki planszy na podstawie rozmiaru planszy.
 * @param {number} boardSize - Rozmiar planszy
 * @function
 */
function initializeBoard(boardSize) {
    board.style.gridTemplateColumns = `repeat(${boardSize}, 30px)`;

    for (let i = 0; i &lt; boardSize * boardSize; i++) {
        createCell(i);
    }
}

/**
 * Rozpoczyna grƒô.
 * Ustawia flagƒô informujƒÖcƒÖ, ≈ºe gra zosta≈Ça rozpoczƒôta.
 * Pobiera nazwƒô gracza z pola wej≈õciowego i usuwa bia≈Çe znaki z poczƒÖtku i ko≈Ñca.
 * Sprawdza, czy nazwa gracza zosta≈Ça podana.
 * Je≈õli nie to:
 * Wy≈õwietla alert, je≈õli nazwa gracza nie zosta≈Ça podana, i przerywa dalsze wykonywanie funkcji.
 * Pobiera wybrany poziom trudno≈õci.
 * Ustala rozmiar planszy i liczbƒô min w zale≈ºno≈õci od wybranego poziomu trudno≈õci.
 * Wy≈ÇƒÖcza pole wprowadzania nazwy gracza.
 * Generuje miny na planszy.
 * Resetuje licznik ods≈Çoniƒôtych kom√≥rek.
 * Oblicza liczbƒô pozosta≈Çych do ods≈Çoniƒôcia kom√≥rek.
 * Rozpoczyna liczenie czasu gry.
 * Czy≈õci planszƒô z kom√≥rek.
 * Inicjalizuje planszƒô gry na podstawie ustalonego rozmiaru.
 * Ustawia liczbƒô dostƒôpnych flag na poczƒÖtkowƒÖ liczbƒô min.
 * @function
 */
function startGame() {
    gameStarted = true;
    const playerName = playerNameInput.value.trim();
    if (!playerName) {
        alert("Please enter your name!");
        return;
    }

    const difficulty = difficultySelect.value;
    let boardSize;
    let mineCount;

    switch (difficulty) {
        case "easy":
            boardSize = 8;
            mineCount = 10;
            break;
        case "normal":
            boardSize = 10;
            mineCount = 15;
            break;
        case "hard":
            boardSize = 12;
            mineCount = 20;
            break;
        default:
            boardSize = 8;
            mineCount = 10;
    }

    playerNameInput.disabled = true;
    mines = generateMines(boardSize, mineCount);
    revealedCells = 0;
    remainingCells = boardSize * boardSize - mineCount;
    startTime = Date.now();
    timer();
    board.innerHTML = "";
    initializeBoard(boardSize);
    flagCount = mineCount;
    updateFlagCount();
}

/**
 * Generuje miny na planszy.
 * Tworzy tablicƒô o rozmiarze r√≥wnym liczbie kom√≥rek planszy i wype≈Çnia jƒÖ warto≈õciami false.
 * Losuje pozycje min na planszy.
 * Wybiera losowy indeks, kt√≥ry jeszcze nie zawiera miny.
 * Ustawia minƒô na wylosowanej pozycji.
 * Zwraca tablicƒô reprezentujƒÖcƒÖ miny na planszy.
 * @param {number} boardSize - Rozmiar planszy
 * @param {number} mineCount - Liczba min
 * @returns {boolean[]} Tablica reprezentujƒÖca miny na planszy
 * @function
 */
function generateMines(boardSize, mineCount) {
    const mineArray = Array(boardSize * boardSize).fill(false);
    for (let i = 0; i &lt; mineCount; i++) {
        let randomIndex;
        do {
            randomIndex = Math.floor(Math.random() * (boardSize * boardSize));
        } while (mineArray[randomIndex]);
        mineArray[randomIndex] = true;
    }
    return mineArray;
}

/**
 * Rozpoczyna pomiar czasu gry.
 * Aktualizuje licznik czasu.
 * Ustawia interwa≈Ç od≈õwie≈ºania licznika czasu co 1000 milisekund (1 sekunda).
 * @function
 */
async function timer() {
    updateTimer();
    timerInterval = setInterval(updateTimer, 1000);
}

/**
 * Zatrzymuje pomiar czasu gry.
 * Usuwa interwa≈Ç od≈õwie≈ºania licznika czasu.
 * @function
 */
function stopTimer() {
    clearInterval(timerInterval);
}

/**
 * Aktualizuje czas na wy≈õwietlaczu.
 * Oblicza up≈ÇywajƒÖcy czas od rozpoczƒôcia gry w sekundach.
 * Aktualizuje tekst wy≈õwietlacza czasu gry.
 * @function
 */
function updateTimer() {
    const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
    timerDisplay.textContent = `‚è∞ ${elapsedTime}s`;
}

/**
 *  Zapisuje wynik gracza w pamiƒôci lokalnej przeglƒÖdarki.
 *  Pobiera nazwƒô gracza z pola wej≈õciowego na stronie i usuwa bia≈Çe znaki z poczƒÖtku i ko≈Ñca.
 *  Oblicza czas, jaki up≈ÇynƒÖ≈Ç od rozpoczƒôcia gry w sekundach.
 *  Pobiera bie≈ºƒÖcƒÖ listƒô wynik√≥w graczy z pamiƒôci lokalnej.
 *  Dodaje nowy wynik gracza do listy.
 *  Zapisuje zaktualizowanƒÖ listƒô wynik√≥w graczy w pamiƒôci lokalnej.
 *  Aktualizuje wy≈õwietlanie wynik√≥w graczy na stronie.
 * @param {boolean} hasWon - Czy gracz wygra≈Ç?
 * @async
 * @function
 */
async function savePlayerScore(hasWon) {
    const playerName = playerNameInput.value.trim();
    const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
    let playerScores = await getPlayerScores();
    playerScores.push({ name: playerName, time: elapsedTime, won: hasWon });
    localStorage.setItem("playerScores", JSON.stringify(playerScores));
    displayPlayerScores();
}

/**
 * Pobiera wyniki graczy z lokalnej pamiƒôci przeglƒÖdarki.
 * Pobiera zapisane wyniki graczy z lokalnej pamiƒôci przeglƒÖdarki.
 * Je≈õli sƒÖ zapisane wyniki graczy, parsuje je z formatu JSON do tablicy obiekt√≥w.
 * W przeciwnym razie, zwraca pustƒÖ tablicƒô.
 * @returns {object[]} Tablica wynik√≥w graczy
 * @async
 * @function
 */
async function getPlayerScores() {
    const playerScores = localStorage.getItem("playerScores");
    return playerScores ? JSON.parse(playerScores) : [];
}

/**
 * Wy≈õwietla wyniki graczy na stronie internetowej.
 * Pobiera wyniki graczy z pamiƒôci lokalnej przeglƒÖdarki.
 * Czy≈õci zawarto≈õƒá elementu wy≈õwietlajƒÖcego wyniki graczy.
 * Sprawdza, czy istniejƒÖ wyniki graczy.
 * Je≈õli tak to:
 * Tworzy tabelƒô HTML do wy≈õwietlenia wynik√≥w graczy.
 * Tworzy wiersz nag≈Ç√≥wka tabeli.
 * Wype≈Çnia tabelƒô wynikami graczy.
 * Dodaje tabelƒô do elementu wy≈õwietlajƒÖcego wyniki graczy.
 * W przeciwnym razie:
 * Wy≈õwietla komunikat, gdy brak wynik√≥w graczy.
 * @async
 * @function
 * @returns {Promise&lt;void>} Obietnica zako≈Ñczenia wy≈õwietlania wynik√≥w graczy.
 */
async function displayPlayerScores() {
    const playerScores = await getPlayerScores();

    playerScoresDisplay.innerHTML = "&lt;h2>Player Scores&lt;/h2>";
    if (playerScores.length > 0) {
        const table = document.createElement("table");
        const headerRow = table.insertRow();
        headerRow.innerHTML = "&lt;th>Nick&lt;/th>&lt;th>Time&lt;/th>&lt;th>Result&lt;/th>";

        playerScores.forEach(score => {
            const row = table.insertRow();
            row.innerHTML = `&lt;td>${score.name}&lt;/td>&lt;td>${score.time}&lt;/td>&lt;td>${score.won ? "Won" : "Lost"}&lt;/td>`;
        });

        playerScoresDisplay.appendChild(table);
    } else {
        playerScoresDisplay.innerHTML = "&lt;p>No player scores yet.&lt;/p>";
    }
}

/**
 * Obs≈Çuguje zdarzenie kontekstowe dla planszy (klikniƒôcie prawym przyciskiem myszy).
 * Wstawia lub usuwa flagƒô z kom√≥rki, w zale≈ºno≈õci od jej aktualnego stanu.
 * Zmniejsza licznik dostƒôpnych flag, gdy flaga jest wstawiana, oraz zwiƒôksza go, gdy flaga jest usuwana.
 * @param {Event} event - Zdarzenie kontekstowe
 * @function
 */
function handleContextMenu(event) {
    event.preventDefault();
    
    const clickedCell = event.target;
    const index = parseInt(clickedCell.dataset.index);

    if (!clickedCell.classList.contains("revealed")) {
        if (clickedCell.textContent === "") {
            if (flagCount > 0) {
                clickedCell.textContent = "üö©";
                flagCount--;
                updateFlagCount();
            }
        } else if (clickedCell.textContent === "üö©") {
            clickedCell.textContent = "";
            flagCount++;
            updateFlagCount();
        }
    }
}
/**
 * Aktualizuje wy≈õwietlacz liczby flag.
 * Aktualizuje tekst wy≈õwietlacza liczby flag na stronie internetowej.
 * @function
 */
function updateFlagCount() {
    document.getElementById("flagCount").textContent = flagCount;
}
/**
 * Dodaje obs≈Çugƒô zdarzenia kontekstowego (klikniƒôcie prawym przyciskiem myszy) dla planszy.
 * Wywo≈Çuje funkcjƒô `handleContextMenu` w odpowiedzi na to zdarzenie.
 * @event
 */
board.addEventListener("contextmenu", handleContextMenu);

/**
 * Funkcja wywo≈Çywana po za≈Çadowaniu zawarto≈õci DOM.
 * Inicjalizuje planszƒô gry i wy≈õwietla wyniki graczy.
 * Dodaje r√≥wnie≈º obs≈Çugƒô zdarzenia klikniƒôcia planszy.
 * @event
 */
document.addEventListener("DOMContentLoaded", function() {

    initializeBoard(8);
    displayPlayerScores();
    board.addEventListener('click', function() {
        if (!gameStarted) {
            alert('Start the game');
        }
    });
    
});

/**
 * Czy≈õci wszystkie dane przechowywane w pamiƒôci lokalnej przeglƒÖdarki i aktualizuje wy≈õwietlane wyniki graczy.
 * @function
 */
function clearLocalStorage() {
    localStorage.clear();
    displayPlayerScores();
}



displayPlayerScores();
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#board">board</a></li><li><a href="global.html#checkWinCondition">checkWinCondition</a></li><li><a href="global.html#clearLocalStorage">clearLocalStorage</a></li><li><a href="global.html#countAdjacentMines">countAdjacentMines</a></li><li><a href="global.html#createCell">createCell</a></li><li><a href="global.html#difficultySelect">difficultySelect</a></li><li><a href="global.html#displayPlayerScores">displayPlayerScores</a></li><li><a href="global.html#gameStarted">gameStarted</a></li><li><a href="global.html#generateMines">generateMines</a></li><li><a href="global.html#getNeighbors">getNeighbors</a></li><li><a href="global.html#getPlayerScores">getPlayerScores</a></li><li><a href="global.html#handleCellClick">handleCellClick</a></li><li><a href="global.html#handleContextMenu">handleContextMenu</a></li><li><a href="global.html#initializeBoard">initializeBoard</a></li><li><a href="global.html#mines">mines</a></li><li><a href="global.html#playerNameInput">playerNameInput</a></li><li><a href="global.html#playerScoresDisplay">playerScoresDisplay</a></li><li><a href="global.html#remainingCells">remainingCells</a></li><li><a href="global.html#revealCell">revealCell</a></li><li><a href="global.html#revealMines">revealMines</a></li><li><a href="global.html#revealedCells">revealedCells</a></li><li><a href="global.html#savePlayerScore">savePlayerScore</a></li><li><a href="global.html#startGame">startGame</a></li><li><a href="global.html#startTime">startTime</a></li><li><a href="global.html#stopTimer">stopTimer</a></li><li><a href="global.html#timer">timer</a></li><li><a href="global.html#timerDisplay">timerDisplay</a></li><li><a href="global.html#timerInterval">timerInterval</a></li><li><a href="global.html#updateFlagCount">updateFlagCount</a></li><li><a href="global.html#updateTimer">updateTimer</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Tue Jan 30 2024 19:16:05 GMT+0100 (czas ≈õrodkowoeuropejski standardowy)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
